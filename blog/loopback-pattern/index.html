<!DOCTYPE html>
<html lang="en">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>React Loopback Pattern | alexisvincent.io</title>
<link rel="stylesheet" href="/css/style.css">
<link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/styles/github.min.css">


<section class="section">
  <div class="container">
    <nav class="nav">
      <div class="nav-left">
        <a class="nav-item" href="https://alexisvincent.io"><h1 class="title is-4">alexisvincent.io</h1></a>
      </div>
      <div class="nav-right">
        <nav class="nav-item level is-mobile">
          
          <a class="level-item" href="https://github.com/alexisvincent">
            <span class="icon">
              <i class="fa fa-github"></i>
            </span>
          </a>
          
          <a class="level-item" href="https://twitter.com/vincent_alexis">
            <span class="icon">
              <i class="fa fa-twitter"></i>
            </span>
          </a>
          
          <a class="level-item" href="/index.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>
          </a>
          
        </nav>
      </div>
    </nav>
  </div>
</section>

<section class="section">
  <div class="container">
    <h2 class="subtitle is-6">October 4, 2017</h2>
    <h1 class="title">React Loopback Pattern</h1>
    <div class="content">
      

<p>I recently implemented a neat react pattern for creating dumb components in situations where it would normally be easier to allow the component to contain internal state.</p>

<p><strong><em>I am not claiming this is going to revolutionize anything, it&rsquo;s just a very simple idea (that people are probably already doing) that might make some stuff simpler for anyone who has not seen it yet</em></strong></p>

<h2 id="definition">Definition</h2>

<p>The loopback pattern is an extention of the &ldquo;smart/dumb&rdquo; component pattern, where dumb components accept two props <code>data</code> and the <code>loopback</code> function.</p>

<ul>
<li><code>state</code> is then what we would normally pass to a dumb component, it defines the state of the dumb component</li>

<li><p><code>loopback</code> is a reducer/callback function  accepting <code>(event, suggestedState, ...)</code>, where</p>

<ul>
<li><code>event</code> is an object/action containing information describing some event/change generated by the dumb component</li>
<li><code>suggestedState</code> is a new state object generated by the dumb component containing the &lsquo;next&rsquo; state it thinks it should be in</li>
<li><code>...</code> there are some usefull extentions we can make to this pattern that make it more powerful, but they aren&rsquo;t required and can be discussed later</li>
</ul></li>
</ul>

<h2 id="short-example">Short Example</h2>

<pre><code class="language-js">
// displays items and onClick adds item to list
const SillyListComponent = (state, loopback) =&gt; {

    // Called when the &quot;Generate new Item&quot; button is clicked
    const generateNewItem = () =&gt; {

        // construct an object describing the event/change
        const itemEvent = { type: 'NEW_ITEM', item: { name: 'Yay new Item' } }

        // generate the suggested state after the event has been handled
        // this function should be augmented to handle other events as they are handled
        const handleItemEvent = (itemEvent, state) =&gt; ({
            ...state,
            items: { ...state, itemEvent.item }
        })

        // call the loopback function passing the event and the suggested state to the parent
        loopback(itemEvent, handleItemEvent(itemEvent), /** optionally pass in handleItemEvent **/)
    }

    return (
        &lt;div&gt;
            {state.items.map(item =&gt; &lt;div&gt;{item.name}&lt;/div&gt;)}
            &lt;div onClick={makeRandomNewItem()}&gt;Generate new Item&lt;/div&gt;
        &lt;/div&gt;
    )
}

class App extends React.Component {

    state = {
        items: [ { name: 'first Item' }]
    }

    // handle event generated in SillyList component
    listLoopback = (itemEvent, suggestedState) =&gt; {
        // no special handling, we just use the suggested state
        this.setState(suggestedState)
    }

    return (&lt;SillyListComponent state={this.state} loopback={suggestedState} /&gt;)
}
</code></pre>

<h2 id="brief-motivation">Brief motivation</h2>

<p>This mechanism gives complete control to the parent component, instead of the list component
managing it&rsquo;s state, this becomes the job of the parent. We get this anyway with Dumb/Smart
components to some degree but this extends the pattern slightly by pulling ALL internal state
into the parent component, allowing you to store it as you see fit.</p>

<p>But the most important gain is that we don&rsquo;t loose the domain knowledge of the component. We
don&rsquo;t want to have to understant all the state manipulation of the &lsquo;dumb&rsquo; component. Imagine it&rsquo;s
job was to approximate points along a path linearization, and insert the generated result into a
number of places in the state. Or to reorder a list.</p>

<p>This approach pulls control out of the component without loosing the domain specific functionality.</p>

<h1 id="more-substantial-motivation-everything-below-i-havn-t-looked-at-in-many-months">More Substantial Motivation (everything below I havn&rsquo;t looked at in many months)</h1>

<h2 id="the-scene-wip">The Scene (WIP)</h2>

<p>Let&rsquo;s imagine we wanted to create a component to render and interact with tables. This component should support the following:</p>

<ul>
<li>Rendering tablular data</li>
<li>Support for client or server side filtering/ordering/grouping</li>
<li>Pagination</li>
<li>Optimistic UI updates</li>
</ul>

<p>Upon clicking on any of the header cells, we&rsquo;d like the parent component to be notified and to handle sorting/ordering/grouping of the data (server or client side), we also
need the data to &lsquo;grey out&rsquo; to indicate that we are fetching data. Cell click and hover events should be propogated to the parent component and interacting with the pagination
navigation should notify the parent.</p>

<h2 id="think-tank-wip">Think Tank (WIP)</h2>

<p>Traditionally I might have approached this via some combination of internal state and callbacks. For example:</p>

<ul>
<li>Handle clicks via a clickHandler(column: int, row:int) callback</li>
<li>Apon clicking a cell header

<ol>
<li>&lsquo;grey out&rsquo; data (via internal state)</li>
<li>run orderBy(order: &lsquo;ASC&rsquo;|&lsquo;DESC&rsquo;) callback</li>
<li>listen for notification of new data</li>
</ol></li>
<li>Handle pagination navigation via pageChanged(page: int) callback</li>
</ul>

<p>There are a few limitations with this approch
- Data such as pagination index, ordering column, and &lsquo;greyed out&rsquo; flag are hidden in state component
- Can&rsquo;t serialize and store table state with the rest of the app state (in Redux store for instance)
- Start having to write a lot of callback handlers
- Lack of control over internal state changes
    - Does page number increase before or after new data has arrived
    - Same thing for ordering ui indicator (before or after new data has arrived)
    - What if making a field sort via ASC instead of DESC doesn&rsquo;t change data? We might not want to &lsquo;grey out&rsquo; data.</p>

<p>So I wanted to pull out component state into the parent component and render solely based on props. However I didn&rsquo;t
want to have to decide state transisions in the parent component as this would conflate responsibilities.</p>

<h2 id="the-pattern-wip">The Pattern (WIP)</h2>

<p>The pattern I landed on is heavily inspired by redux.</p>

<p>You start by storing the initial state of the component (the props you would use to render it) in some state store. This could
be the state of the parent component, or something like a redux store. This is passed to the component via props somehow. In the example
below I have &hellip;spread it in.</p>

<p>Internally, the component is rendered as a function solely from props. When some change is detected (eg. change order by column, choose next page),
an action describing the change is generated, the component then generates a suggested new state, as a function of the old state and the action
(like a redux reducer). It then passes the new state, the action and the old state back to the parent component. The parent component receives these
(via the loopback function passed in props) and makes a decision about what to do with the new state.</p>

<pre><code class="language-js">import {Component} from 'react'
import Table from './table'

export default
class ProductsPage extends Component {

    constructor() {
        super()

        this.state = {

            // The state of the table component (will be spread in via props)
            tableState: {
                rowHeight: 30,
                headerHeight: 30,
                currentPage: 1,
                totalPages: 1,

                columns: [
                    { weight: 1, header: &quot;ID&quot;, order: 'ASC' },
                    { weight: 1, header: &quot;Name&quot; },
                    { weight: 1, header: &quot;Short Name&quot; },
                ],

                data: [
                    ['1', 'Ma Super Awsome Shoes Yeah', 'Bedazled Shoes'],
                    ['2', 'Some Sick Glasses Mahn', 'MSG '],
                ]
            }
        }
    }

    /*
     * The loopback function we pass to the table component to receive table interaction
     * 
     * @var suggested  the new state that the table component computed for itself
     * @var action     the action object describing the change
     * @var current    the current props the table is being rendered from
     */
    tableLoopback = (suggested, action, current) =&gt; {

        /* Here we always just set the table state to the suggested state, (React automatically renders after setState).
         * Note, you can ignore suggested state completely. Had we passed in an empty function, all UI interaction would be ignored
         */
        this.setState({tableState: suggested})
    }

    render() {
        return &lt;Table {...this.state.tableState}       // Spread in the table state
                      loopback={this.tableLoopback} /&gt; // Pass the loopback function
    }
}
</code></pre>

    </div>
  </div>
</section>

<section class="section">
  <div class="container">
    <aside><div id="disqus_thread"></div></aside>
    <script type="text/javascript">
      var disqus_shortname = 'alexisjohnvincent';
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
  </div>
</section>


<section class="section">
  <div class="container has-text-centered">
    <p>&copy; <a href="https://github.com/alexisvincent">Alexis Vincent</a> 2017</p>
  </div>
</section>
<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/highlight.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/languages/go.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/languages/dockerfile.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.6.0/languages/javascript.min.js"></script>

<script>hljs.initHighlightingOnLoad();</script>


